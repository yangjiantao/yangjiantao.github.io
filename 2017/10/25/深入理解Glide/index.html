<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android glide 源码," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。 目前，Glide的最新稳定版本为4.1.1，本文也是基于这个版本来分析的。 基本用法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123456Glide.with(fragment)    .loa">
<meta name="keywords" content="android glide 源码">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Glide">
<meta property="og:url" content="https://github.com/yangjiantao/2017/10/25/深入理解Glide/index.html">
<meta property="og:site_name" content="Jiantao">
<meta property="og:description" content="Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。 目前，Glide的最新稳定版本为4.1.1，本文也是基于这个版本来分析的。 基本用法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123456Glide.with(fragment)    .loa">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-10-26T03:38:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Glide">
<meta name="twitter:description" content="Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。 目前，Glide的最新稳定版本为4.1.1，本文也是基于这个版本来分析的。 基本用法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123456Glide.with(fragment)    .loa">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/yangjiantao/2017/10/25/深入理解Glide/"/>





  <title>深入理解Glide | Jiantao</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jiantao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">android developer</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yangjiantao/2017/10/25/深入理解Glide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiantao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar_x225.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiantao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Glide</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T23:29:06+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/10/25/深入理解Glide/" class="leancloud_visitors" data-flag-title="深入理解Glide">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>
<p>目前，Glide的最新稳定版本为4.1.1，本文也是基于这个版本来分析的。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>多数情况下，使用Glide加载图片非常简单，一行代码足矣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Glide.with(fragment)</div><div class="line">    .load(myUrl)</div><div class="line">    .into(imageView);</div><div class="line">    </div><div class="line">```    </div><div class="line">取消加载同样很简单：</div></pre></td></tr></table></figure>
<p>Glide.with(fragment).clear(imageView);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- asBitmap() //指定加载静态图片，如果是gif则加载第一帧。</div><div class="line">- asGif() //如果是非gif，则加载失败。</div><div class="line">- asXxx() // 较3.x新增了几个as方法。</div><div class="line"></div><div class="line"></div><div class="line">### 注解生成流式API（与3.x版本最大区别）</div><div class="line"></div><div class="line"></div><div class="line">Glide v4 使用 注解处理器 (Annotation Processor) 来生成出一个 API，在 Application 模块中可使用该流式 API 一次性调用到 RequestBuilder， RequestOptions 和集成库中所有的选项。</div><div class="line"></div><div class="line">**Generated API 模式的设计出于以下两个目的**：</div><div class="line"></div><div class="line">- 集成库可以为 Generated API 扩展自定义选项。</div><div class="line">- 在 Application 模块中可将常用的选项组打包成一个选项在 Generated API 中使用</div><div class="line"></div><div class="line">虽然以上所说的工作均可以通过手动创建 RequestOptions 子类的方式来完成，但想将它用好更具有挑战，并且降低了 API 使用的流畅性。</div><div class="line"></div><div class="line">### 使用 Generated API</div><div class="line"></div><div class="line">Generated API 默认名为 GlideApp ，与 Application 模块中 AppGlideModule的子类包名相同。在 Application 模块中将 Glide.with() 替换为 GlideApp.with()，即可使用该 API 去完成加载工作：</div></pre></td></tr></table></figure>
<p>GlideApp.with(fragment)<br>   .load(myUrl)<br>   .placeholder(R.drawable.placeholder)<br>   .fitCenter()<br>   .into(imageView);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">与 Glide.with() 不同，诸如 fitCenter() 和 placeholder() 等选项在 Builder 中直接可用，并不需要再传入单独的 RequestOptions 对象。 </div><div class="line"></div><div class="line">当然，Glide也支持kotlin，更多用法请参考官网。</div><div class="line">[Glide中文文档](https://muyangmin.github.io/glide-docs-cn/)、[英文文档](http://bumptech.github.io/glide/)</div><div class="line"></div><div class="line"></div><div class="line">## 工作流程</div><div class="line"></div><div class="line">本节主要从源码角度分析Glide的主体工作流程，相信阅读完本节内容，你对Glide会有更清晰的认识。</div><div class="line"></div><div class="line">### 简易流程图</div><div class="line"></div><div class="line">![glide-flow-diagram](http://upload-images.jianshu.io/upload_images/2217296-b5e3af2f20d87813.png)</div><div class="line"></div><div class="line">你可能现在看不太懂，没关系。下面会从源码角度分析Glide整个执行过程，完了之后，我们在回过来看也许就明白了。</div><div class="line"></div><div class="line"></div><div class="line">由于Glide源码较复杂，阅读前最好明确目标，认准一个功能点，然后分析这个功能点如何实现即可，**只追求主体实现逻辑，莫纠缠细节，点到为止**。你说，我就想琢磨细节实现咋办？待下个回合将你这个细节作为目标带入分析，如此循环，各个击破。</div><div class="line"></div><div class="line">以上，是我阅读源码的一些建议，希望对你有帮助。</div><div class="line"></div><div class="line">下面，我们就以图作路，分析下面这句代码。</div></pre></td></tr></table></figure>
<p>Glide.with(fragment).load(myUrl).into(imageView);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">目标很明确。**Glide是如何将这张图片加载并显示到组件上的？** 从问题切入，到代码里找答案。</div><div class="line"></div><div class="line">把图片加载并显示，这个过程，我理解就三步：</div><div class="line">1. 创建request</div><div class="line">2. 执行加载过程</div><div class="line">3. 回调刷新UI</div><div class="line"></div><div class="line">#### 创建request</div><div class="line"></div><div class="line">- 从Glide.with()方法开始</div></pre></td></tr></table></figure></p>
<p>  public static RequestManager with(Activity activity) {<br>    return getRetriever(activity).get(activity);<br>  }</p>
<p>  public static RequestManager with(FragmentActivity activity) {<br>    return getRetriever(activity).get(activity);<br>  }</p>
<p>  public static RequestManager with(Fragment fragment) {<br>    return getRetriever(fragment.getActivity()).get(fragment);<br>  }</p>
<p>  public static RequestManager with(android.app.Fragment fragment) {<br>    return getRetriever(fragment.getActivity()).get(fragment);<br>  }</p>
<p>   public static RequestManager with(Context context) {<br>    return getRetriever(context).get(context);<br>  }</p>
<p>  //4.x新增<br>  public static RequestManager with(View view) {<br>    return getRetriever(view.getContext()).get(view);<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以看出，with方法重载种类多，值得说一点是，4.x新增了View参数的重载，这样便于在view类中使用。with方法比较简单，重载也是为了方便调用。</div><div class="line"></div><div class="line">我们要知道RequestManager对象是怎么创建的？就先来看看getRetriever()方法。</div></pre></td></tr></table></figure>
<p>private static RequestManagerRetriever getRetriever(@Nullable Context context) {<br>    // Context could be null for other reasons (ie the user passes in null), but in practice it will<br>    // only occur due to errors with the Fragment lifecycle.<br>    Preconditions.checkNotNull(<br>        context,<br>        “You cannot start a load on a not yet attached View or a  Fragment where getActivity() “</p>
<pre><code>        + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;
        + &quot;is attached or after the Fragment is destroyed).&quot;);
return Glide.get(context).getRequestManagerRetriever();
</code></pre><p>  }</p>
<p>   /**</p>
<ul>
<li>Get the singleton.<br>*</li>
<li><p>@return the singleton<br>*/<br>public static Glide get(Context context) {<br>if (glide == null) {<br> synchronized (Glide.class) {<br>   if (glide == null) {</p>
<pre><code>checkAndInitializeGlide(context);
</code></pre><p>   }<br> }<br>}</p>
<p>return glide;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以上代码可以看出，RequestManagerRetriever对象通过Glide实例获取，而Glide实例是通过单利模式创建的，这里单利也是经典的“双重校验”模式。有关Glide实例化的细节，我们后面用到再讲。</div><div class="line"></div><div class="line">那问题简单了，RequestManager对象就是通过RequestManagerRetriever的get方法创建并返回的。</div></pre></td></tr></table></figure>
<p>//get方法也像with一样，有多个重载，这里只贴出一个代表性的。<br>public RequestManager get(Context context) {<br>    if (context == null) {<br>      throw new IllegalArgumentException(“You cannot start a load on a null Context”);<br>    //num=0 这里如果是非主线程，直接返回applicationManager<br>    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {<br>      if (context instanceof FragmentActivity) {<br>        return get((FragmentActivity) context);<br>      } else if (context instanceof Activity) {<br>        return get((Activity) context);<br>      } else if (context instanceof ContextWrapper) {<br>        return get(((ContextWrapper) context).getBaseContext());<br>      }<br>    }<br>    //传入的Context为ApplicationContext<br>    return getApplicationManager(context);<br>  }</p>
<p>  //get(Activity)/get(Fragment)逻辑差不多，这里分析以下这种类型。<br>  public RequestManager get(FragmentActivity activity) {<br>    if (Util.isOnBackgroundThread()) {<br>      return get(activity.getApplicationContext());<br>    } else {<br>      assertNotDestroyed(activity);<br>      FragmentManager fm = activity.getSupportFragmentManager();<br>      return supportFragmentGet(activity, fm, null /<em>parentHint</em>/);<br>    }<br>  }</p>
<p>  private RequestManager supportFragmentGet(Context context, FragmentManager fm,<br>      Fragment parentHint) {<br>      //num=1 获取managerFragment<br>    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);<br>    RequestManager requestManager = current.getRequestManager();<br>    if (requestManager == null) {<br>      // TODO(b/27524013): Factor out this Glide.get() call.<br>      Glide glide = Glide.get(context);<br>      //num=2 创建requestManager ，并传入了Lifecycle<br>      requestManager = factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());<br>     //num=3 缓存requestManager,保证一个Activity对应一个requestManager<br>      current.setRequestManager(requestManager);<br>    }<br>    return requestManager;<br>  }</p>
<p>  //num=4 创建并添加一个SupportRequestManagerFragment<br>  SupportRequestManagerFragment getSupportRequestManagerFragment(<br>      final FragmentManager fm, Fragment parentHint) {<br>    SupportRequestManagerFragment current =<br>        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);<br>    if (current == null) {<br>      current = pendingSupportRequestManagerFragments.get(fm);<br>      if (current == null) {<br>        current = new SupportRequestManagerFragment();<br>        current.setParentFragmentHint(parentHint);<br>        pendingSupportRequestManagerFragments.put(fm, current);<br>        //num=5 这里添加一个隐藏的Fragment<br>        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();<br>        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();<br>      }<br>    }<br>    return current;<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">以上为RequestManagerRetriever类，我只贴了部分重要的代码。</div><div class="line"></div><div class="line">可以看出get方法重载参数虽然很多，但最终就返回两种类型的requestManager。一种是ApplicationManager,它自动和应用的生命周期同步，应用退出，Glide也就停止加载；另外一种则是带有Fragment生命周期的requestManager。对应上述代码中 **num=1-5**注释，可以看出，Glide添加一个隐藏的Fragment，获取对应的生命周期回调事件，这样就可在Activity销毁时停止加载图片了。这种方式比较巧妙，不仅是Glide，RxPermission项目也是这样使用的。</div><div class="line"></div><div class="line">到这里Glide.with()方法就分析完了。它主要完成了Glide实例化，并返回requestManager对象。</div><div class="line"></div><div class="line"></div><div class="line">- 再看load(url)方法</div></pre></td></tr></table></figure>
<p>//这里默认调用的asDrawable，表示下载后要转换的类型。<br>//当然也可以设置其它类型，比如asBitmap、asFile，都类似，这里就不展开分析了。<br>  public RequestBuilder<drawable> load(@Nullable Object model) {<br>    return asDrawable().load(model);<br>  }</drawable></p>
<p>  //最终后走到这里。<br>  private RequestBuilder<transcodetype> loadGeneric(@Nullable Object model) {<br>    this.model = model;<br>    isModelSet = true;<br>    return this;<br>  }</transcodetype></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load方法比较简单，根据传入的model类型对应有多个重载，但最终也只是将其缓存到model变量。这一节，我们是分析request的创建，现在到了RequestBuilder，看名字就知道是创建request的，哪它在哪里创建的呢？我们接着看into方法。</div></pre></td></tr></table></figure>
<p>public Target<transcodetype> into(ImageView view) {<br>    Util.assertMainThread();<br>    Preconditions.checkNotNull(view);</transcodetype></p>
<pre><code>if (!requestOptions.isTransformationSet()
    &amp;&amp; requestOptions.isTransformationAllowed()
    &amp;&amp; view.getScaleType() != null) {
  if (requestOptions.isLocked()) {
    requestOptions = requestOptions.clone();
  }
  switch (view.getScaleType()) {
    case CENTER_CROP:
      requestOptions.optionalCenterCrop();
      break;
    case CENTER_INSIDE:
      requestOptions.optionalCenterInside();
      break;
    case FIT_CENTER:
    case FIT_START:
    case FIT_END:
      requestOptions.optionalFitCenter();
      break;
    case FIT_XY:
      requestOptions.optionalCenterInside();
      break;
    case CENTER:
    case MATRIX:
    default:
      // Do nothing.
  }
}
//以上逻辑是转换相关的，不看。只关注这句代码。
return into(context.buildImageViewTarget(view, transcodeClass));
</code></pre><p>  }</p>
<p>  //创建一个ImageViewTarget，用于后续更新UI<br>  public <x> Target<x> buildImageViewTarget(ImageView imageView, Class<x> transcodeClass) {<br>    return imageViewTargetFactory.buildTarget(imageView, transcodeClass);<br>  }</x></x></x></p>
<p>  public class ImageViewTargetFactory {</p>
<p>  //根据类型返回target。因为load方法默认使用的是asDrawable，这里默认返回的是DrawableImageiewTarget。<br>  @SuppressWarnings(“unchecked”)<br>  public <z> Target<z> buildTarget(ImageView view, Class<z> clazz) {<br>    if (Bitmap.class.equals(clazz)) {<br>      return (Target<z>) new BitmapImageViewTarget(view);<br>    } else if (Drawable.class.isAssignableFrom(clazz)) {<br>      return (Target<z>) new DrawableImageViewTarget(view);<br>    } else {<br>      throw new IllegalArgumentException(<br>          “Unhandled class: “ + clazz + “, try .as*(Class).transcode(ResourceTranscoder)”);<br>    }<br>  }<br>}</z></z></z></z></z></p>
<p>//target创建好了，就接着看into(Y target)方法</p>
<p>public <y extends="" target<transcodetype="">&gt; Y into(@NonNull Y target) {<br>    Util.assertMainThread();<br>    Preconditions.checkNotNull(target);<br>    if (!isModelSet) {<br>      throw new IllegalArgumentException(“You must call #load() before calling #into()”);<br>    }</y></p>
<pre><code>requestOptions.lock();
//这里创建的request
Request request = buildRequest(target);
Request previous = target.getRequest();

if (request.isEquivalentTo(previous)
  &amp;&amp; (Preconditions.checkNotNull(previous).isComplete()
     || Preconditions.checkNotNull(previous).isRunning())) {
  request.recycle();

  if (!Preconditions.checkNotNull(previous).isRunning()) {
    previous.begin();
  }
  return target;
}

requestManager.clear(target);
target.setRequest(request);
//这里执行request
requestManager.track(target, request);

return target;
</code></pre><p>  }</p>
<p>  //接着看buildRequest(target)</p>
<p>  private Request buildRequest(Target<transcodetype> target) {<br>    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),<br>        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());<br>  }</transcodetype></p>
<p>  private Request buildRequestRecursive(Target<transcodetype> target,<br>      @Nullable ThumbnailRequestCoordinator parentCoordinator,<br>      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,<br>      Priority priority, int overrideWidth, int overrideHeight) {</transcodetype></p>
<pre><code>// 省略一大堆其它逻辑代码（缩放相关）
// Base case: no thumbnail.
return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
    overrideWidth, overrideHeight);
</code></pre><p>  }</p>
<p>  private Request obtainRequest(Target<transcodetype> target,<br>      RequestOptions requestOptions, RequestCoordinator requestCoordinator,<br>      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority,<br>      int overrideWidth, int overrideHeight) {<br>    requestOptions.lock();<br>    //可以看到这里通过SingleRequest.obtain创建的Request，内部就是new一个SingleRequest对象并赋值相关属性，就不贴代码了。<br>    // 但是需要搞清楚几个属性的值，我在下面代码中注释。<br>    return SingleRequest.obtain(<br>        context,<br>        model,//对应load(myUrl)，比如一个图片地址。<br>        transcodeClass,//转换类型，这里默认对应Drawable.class<br>        requestOptions,<br>        overrideWidth,//宽<br>        overrideHeight,<br>        priority,<br>        target,<br>        requestListener,<br>        requestCoordinator,<br>        context.getEngine(),//全局加载引擎<br>        transitionOptions.getTransitionFactory());<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">到这里Request的创建就分析完了，最终是生成了一个SingleRequest实例。简单回顾下。还是在那句代码贴过来。</div></pre></td></tr></table></figure></transcodetype></p>
<p>Glide.with(fragment).load(myUrl).into(imageView);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">咋一看都分析差不多了，但这只是假象。into方法逻辑甚多，加载、缓存、转换等都在那里完成。so，我们继续。</div><div class="line"></div><div class="line">#### 执行加载数据</div><div class="line">我们先回到RequestBuilder类中into(Y target)方法，也是执行加载的入口。</div></pre></td></tr></table></figure></p>
<p>public <y extends="" target<transcodetype="">&gt; Y into(@NonNull Y target) {<br>    … 省略<br>    requestManager.clear(target);<br>    target.setRequest(request);<br>    //跟进manager的track方法<br>    requestManager.track(target, request);<br>}</y></p>
<p>void track(Target&lt;?&gt; target, Request request) {<br>    targetTracker.track(target);<br>    requestTracker.runRequest(request);<br>  }</p>
<p>  /**</p>
<ul>
<li><p>Starts tracking the given request.<br>*/<br>public void runRequest(Request request) {<br>requests.add(request);<br>if (!isPaused) {<br> request.begin();<br>} else {<br> pendingRequests.add(request);<br>}<br>}</p>
<p>//以下是SingleRequest类中begin方法实现。<br>@Override<br>public void begin() {<br>stateVerifier.throwIfRecycled();<br>startTime = LogTime.getLogTime();<br>//num=0<br>if (model == null) {<br> onLoadFailed(new GlideException(“Received null model”), logLevel);<br> return;<br>}</p>
<p>if (status == Status.RUNNING) {<br> throw new IllegalArgumentException(“Cannot restart a running request”);<br>}</p>
<p>//num=3<br>if (status == Status.COMPLETE) {<br> onResourceReady(resource, DataSource.MEMORY_CACHE);<br> return;<br>}</p>
<p>//num=1<br>status = Status.WAITING_FOR_SIZE;<br>if (Util.isValidDimensions(overrideWidth, overrideHeight)) {<br> onSizeReady(overrideWidth, overrideHeight);<br>} else {<br> target.getSize(this);<br>}</p>
<p>//num=2<br>if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)<br>   &amp;&amp; canNotifyStatusChanged()) {<br> target.onLoadStarted(getPlaceholderDrawable());<br>}<br>if (Log.isLoggable(TAG, Log.VERBOSE)) {<br> logV(“finished run method in “ + LogTime.getElapsedMillis(startTime));<br>}<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码分别来至几个类。很容易看出执行流程：into()=&gt;track()=&gt;runRequest()=&gt;begin()，这里分析下begin方法。</div><div class="line"></div><div class="line">- **num=0**（对应代码中注释num=0处）</div><div class="line"></div><div class="line">  可以看到判断model变量为null，就回调onLoadFailed方法，这个方法就会设置我们配置的error placeholder资源。**这里的model变量就是我们通过load(myUrl)方法传入的图片地址。**</div><div class="line">  </div><div class="line">- **num=1**</div><div class="line">  </div><div class="line">  这里主要是判断overrideWidth, overrideHeight是否可用。分两种情况：1.如果设置了override(int width, int height) ,直接处理onSizeReady方法逻辑。2.没有设置override，Glide就会计算组件宽高并回调onSizeReady。所以两种情况**最后都会调用onSizeReady方法**。   </div><div class="line">- **num=2**</div><div class="line"></div><div class="line">  开始前，回调设置placeholderDrawable，和num=0类似。 </div><div class="line">- **num=3**</div><div class="line">  </div><div class="line">  加载完成回调。这里是加载、缩放、转换之后的数据，可直接用于UI显示。后面再分析是怎么回调刷新UI的。</div><div class="line"></div><div class="line">到这里，默认流程就会走到onSizeReady方法。</div></pre></td></tr></table></figure>
<p>@Override<br>  public void onSizeReady(int width, int height) {<br>    …省略<br>    //Engine类的load方法，正式步入加载流程。<br>    loadStatus = engine.load(<br>        glideContext,<br>        model,//对应myUrl,图片地址<br>        requestOptions.getSignature(),<br>        this.width,<br>        this.height,<br>        requestOptions.getResourceClass(),//默认是Object.class<br>        transcodeClass, //默认Drawbale.class<br>        priority,<br>        requestOptions.getDiskCacheStrategy(),//缓存策略。默认是AUTOMATIC<br>        requestOptions.getTransformations(),<br>        requestOptions.isTransformationRequired(),<br>        requestOptions.isScaleOnlyOrNoTransform(),<br>        requestOptions.getOptions(),<br>        requestOptions.isMemoryCacheable(),<br>        requestOptions.getUseUnlimitedSourceGeneratorsPool(),<br>        requestOptions.getOnlyRetrieveFromCache(),<br>        this);</p>
<p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以看到，调用了Engine的load方法。重点来了。</div></pre></td></tr></table></figure>
<p>public <r> LoadStatus load(<br>      GlideContext glideContext,<br>      Object model,<br>      Key signature,<br>      int width,<br>      int height,<br>      Class&lt;?&gt; resourceClass,<br>      Class<r> transcodeClass,<br>      Priority priority,<br>      DiskCacheStrategy diskCacheStrategy,<br>      Map<class<?>, Transformation&lt;?&gt;&gt; transformations,<br>      boolean isTransformationRequired,<br>      boolean isScaleOnlyOrNoTransform,<br>      Options options,<br>      boolean isMemoryCacheable,<br>      boolean useUnlimitedSourceExecutorPool,<br>      boolean onlyRetrieveFromCache,<br>      ResourceCallback cb) {<br>    Util.assertMainThread();<br>    long startTime = LogTime.getLogTime();</class<?></r></r></p>
<pre><code>//生成缓存key
EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
    resourceClass, transcodeClass, options);

//num=4 从内存缓存中读取
EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
if (cached != null) {
  cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
  if (Log.isLoggable(TAG, Log.VERBOSE)) {
    logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);
  }
  return null;
}
//num=5 如果上一步没有命中，则从ActiveResource中读取。
EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
if (active != null) {
  cb.onResourceReady(active, DataSource.MEMORY_CACHE);
  if (Log.isLoggable(TAG, Log.VERBOSE)) {
    logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);
  }
  return null;
}

//囧，也没命中。检查当前Request是否正在执行。
EngineJob&lt;?&gt; current = jobs.get(key);
if (current != null) {
  //不为null，缓存回调函数，等待完成后执行。
  current.addCallback(cb);
  if (Log.isLoggable(TAG, Log.VERBOSE)) {
    logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);
  }
  return new LoadStatus(cb, current);
}
//num=6 到这里，就需要创建后台任务了。
EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,
    useUnlimitedSourceExecutorPool);
DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(
    glideContext,
    model,
    key,
    signature,
    width,
    height,
    resourceClass,
    transcodeClass,
    priority,
    diskCacheStrategy,
    transformations,
    isTransformationRequired,
    isScaleOnlyOrNoTransform,
    onlyRetrieveFromCache,
    options,
    engineJob);
jobs.put(key, engineJob);
engineJob.addCallback(cb);
//num=7 开启任务。
engineJob.start(decodeJob);

if (Log.isLoggable(TAG, Log.VERBOSE)) {
  logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);
}
return new LoadStatus(cb, engineJob);
</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- **Glide缓存策略**</div><div class="line"></div><div class="line">    默认情况下，Glide 会在开始一个新的图片请求之前检查以下多级的缓存：</div><div class="line">    </div><div class="line">    1. 活动资源 (Active Resources) - 正在显示的资源</div><div class="line">    2. 内存缓存 (Memory cache) - 显示过的资源 </div><div class="line">    3. 资源类型（Resource） - 被解码、转换后的资源</div><div class="line">    4. 数据来源 (Data) - 源文件（未处理过）资源</div><div class="line">    </div><div class="line">    其实也就是**内存缓存+磁盘缓存**。</div><div class="line">    </div><div class="line">以上代码中 **注释：**num=4、5 处，**表示从内存缓存中获取资源**，如果命中，直接返回，没命中则创建任务并执行（对应 **注释：num=6、7** ）。本文主要分析工作流程，缓存就不细说了。</div><div class="line"></div><div class="line">我们接着往下看，**DecodeJob内部到底做了什么？*，可以说DecodeJob是整个流程中的重点，也是我认为设计得很精妙地方。</div></pre></td></tr></table></figure></p>
<p>//对应上一段代码中num=7处，执行EngineJob的start方法<br>//start方法就是根据diskCacheStrategy策略获取一个executor来执行DecodeJob<br>public void start(DecodeJob<r> decodeJob) {<br>    this.decodeJob = decodeJob;<br>    //这里根据缓存策略，决定使用哪个Executor。默认情况返回diskCacheExecutor。<br>    //共三种执行器：diskCacheExecutor、sourceExecutor、sourceUnlimitedExecutor对应文章前面给出的流程图。<br>    GlideExecutor executor = decodeJob.willDecodeFromCache()<br>        ? diskCacheExecutor<br>        : getActiveSourceExecutor();<br>    executor.execute(decodeJob);<br>  }</r></p>
<p>//当然，DecodeJob实现了Runnable接口。直接来看它的run方法。<br> @Override<br>  public void run() {<br>    TraceCompat.beginSection(“DecodeJob#run”);<br>    try {<br>      if (isCancelled) {<br>        notifyFailed();<br>        return;<br>      }<br>      runWrapped();//看这里！<br>    } catch (RuntimeException e) {<br>      if (Log.isLoggable(TAG, Log.DEBUG)) {<br>        Log.d(TAG, “DecodeJob threw unexpectedly”</p>
<pre><code>        + &quot;, isCancelled: &quot; + isCancelled
        + &quot;, stage: &quot; + stage, e);
  }
  // When we&apos;re encoding we&apos;ve already notified our callback and it isn&apos;t safe to do so again.
  if (stage != Stage.ENCODE) {
    notifyFailed();
  }
  if (!isCancelled) {
    throw e;
  }
} finally {
  if (currentFetcher != null) {
    currentFetcher.cleanup();
  }
  TraceCompat.endSection();
}
</code></pre><p>  }</p>
<p>//接着看runWrapped方法。<br>//RunReason是一个枚举，默认值为INITIALIZE。区分任务目的。<br>private void runWrapped() {<br>     switch (runReason) {<br>      case INITIALIZE:<br>        stage = getNextStage(Stage.INITIALIZE);<br>        currentGenerator = getNextGenerator();<br>        runGenerators();<br>        break;<br>      case SWITCH_TO_SOURCE_SERVICE:<br>        runGenerators();<br>        break;<br>      case DECODE_DATA:<br>        decodeFromRetrievedData();<br>        break;<br>      default:<br>        throw new IllegalStateException(“Unrecognized run reason: “ + runReason);<br>    }<br>  }</p>
<p>  //获取任务执行阶段：初始化、读取转换后的缓存、读取原文件缓存、原文件加载、结束状态。<br>  private Stage getNextStage(Stage current) {<br>    switch (current) {<br>      case INITIALIZE:<br>        return diskCacheStrategy.decodeCachedResource()<br>            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);<br>      case RESOURCE_CACHE:<br>        return diskCacheStrategy.decodeCachedData()<br>            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);<br>      case DATA_CACHE:<br>        // Skip loading from source if the user opted to only retrieve the resource from cache.<br>        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;<br>      case SOURCE:<br>      case FINISHED:<br>        return Stage.FINISHED;<br>      default:<br>        throw new IllegalArgumentException(“Unrecognized stage: “ + current);<br>    }<br>  }</p>
<p>//根据上一个方法确定的stage，创建对应的Generator(可把它简单理解成资源加载器）<br>  private DataFetcherGenerator getNextGenerator() {<br>    switch (stage) {<br>      case RESOURCE_CACHE:<br>        //从转换后的缓存中读取文件<br>        return new ResourceCacheGenerator(decodeHelper, this);<br>      case DATA_CACHE:<br>       //从原文件缓存中读取文件<br>        return new DataCacheGenerator(decodeHelper, this);<br>      case SOURCE:<br>       //没有缓存，重新加载资源（比如：网络图片、本地文件）<br>        return new SourceGenerator(decodeHelper, this);<br>      case FINISHED:<br>        return null;<br>      default:<br>        throw new IllegalStateException(“Unrecognized stage: “ + stage);<br>    }<br>  }</p>
<p> //这里开始加载执行<br>  private void runGenerators() {<br>    currentThread = Thread.currentThread();<br>    startFetchTime = LogTime.getLogTime();<br>    boolean isStarted = false;<br>    //这里Generator.startNext()方法中就是加载过程，如果成功加载则返回true并跳出循环，否则切换Generator继续执行。<br>    while (!isCancelled &amp;&amp; currentGenerator != null<br>        &amp;&amp; !(isStarted = currentGenerator.startNext())) {<br>      stage = getNextStage(stage);<br>      currentGenerator = getNextGenerator();</p>
<pre><code> //如果任务执行到去加载资源（也就是没有命中磁盘缓存），且切换任务执行环境
  if (stage == Stage.SOURCE) {
    reschedule();
    return;
  }
}
// We&apos;ve run out of stages and generators, give up.
if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {
  notifyFailed();
}

// Otherwise a generator started a new load and we expect to be called back in
// onDataFetcherReady.
</code></pre><p>  }</p>
<p>  @Override<br>  public void reschedule() {<br>    //更改执行目标为：SOURCE服务。当然也只有在stage == Stage.SOURCE的情况下会被调用。<br>    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;<br>    callback.reschedule(this);//这里callback正是EngineJob。<br>  } </p>
<p>  //代码跟进EngineJob类中，可以看到实现方法。<br>  @Override<br>  public void reschedule(DecodeJob&lt;?&gt; job) {<br>    // 可以看到，这里获取的SourceExecutor来执行decodeJob。<br>    //也就巧妙地将此decodeJob任务从cacheExecutor切换到了SourceExecutor，这样分工协作更加高效。<br>    getActiveSourceExecutor().execute(job);<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">以上代码，为方便理解，我加了部分注释。这里再带大家捋一捋逻辑。从最开始没有命中内存缓存开始，然后**执行Engine的start方法**，默认情况会获取到**cacheExecutor执行器**来执行decodeJob任务；继续decodeJob的run方法，因为RunReason==INITIALIZE，接着获取stage，默认情况会返回Stage.RESOURCE_CACHE,这时通过getNextGenerator就返回了**ResourceCacheGenerator加载器**，紧接着就是执行ResourceCacheGenerator，去转换后的缓存中读取文件，如果命中则结束任务并回调结果，反之，切换到**DataCacheGenerator加载器**继续执行，若还是未命中，则切换到**SourceGenerator加载器**（第一次加载没有任何缓存，就会走到这里。），加载完成后结束任务，回调结果，流程结束。</div><div class="line"></div><div class="line">为便于理解，这里在画一张decodeJob内部流程图。</div><div class="line">todo</div><div class="line"></div><div class="line"></div><div class="line">**你可能会问，Glide执行流程就分析完了？ 加载网络图片的代码逻辑都没看到啊？** 按照只分析主流程的思路，点到为止，以上内容就算是分析完了。但相信很多同学都想知道 **加载网络图片代码逻辑到底在哪里？Glide是怎么调用这块代码的？** 面对这两个问题，我们就继续吧。</div><div class="line"></div><div class="line">这里就需要从Glide实例初始化开始说起。我们来看下**Glide的构造方法**。</div></pre></td></tr></table></figure>
<p>  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)<br>  Glide(<br>      Context context,<br>      Engine engine,<br>      MemoryCache memoryCache,<br>      BitmapPool bitmapPool,<br>      ArrayPool arrayPool,<br>      RequestManagerRetriever requestManagerRetriever,<br>      ConnectivityMonitorFactory connectivityMonitorFactory,<br>      int logLevel,<br>      RequestOptions defaultRequestOptions,<br>      Map<class<?>, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions) {<br>    this.engine = engine;<br>    this.bitmapPool = bitmapPool;<br>    this.arrayPool = arrayPool;<br>    this.memoryCache = memoryCache;<br>    this.requestManagerRetriever = requestManagerRetriever;<br>    this.connectivityMonitorFactory = connectivityMonitorFactory;</class<?></p>
<pre><code>DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);

final Resources resources = context.getResources();

//重点看register类，这里调用了各种append、register、prepend等方法。其实就是相关功能类的注册过程。
registry = new Registry();
registry.register(new DefaultImageHeaderParser());

Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
    resources.getDisplayMetrics(), bitmapPool, arrayPool);
ByteBufferGifDecoder byteBufferGifDecoder =
    new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);

registry.register(ByteBuffer.class, new ByteBufferEncoder())
    .register(InputStream.class, new StreamEncoder(arrayPool))
    /* Bitmaps */
    .append(ByteBuffer.class, Bitmap.class,
        new ByteBufferBitmapDecoder(downsampler))
    .append(InputStream.class, Bitmap.class,
        new StreamBitmapDecoder(downsampler, arrayPool))
    .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
    .register(Bitmap.class, new BitmapEncoder())
    /* GlideBitmapDrawables */
    .append(ByteBuffer.class, BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources, bitmapPool,
            new ByteBufferBitmapDecoder(downsampler)))
    .append(InputStream.class, BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources, bitmapPool,
            new StreamBitmapDecoder(downsampler, arrayPool)))
    .append(ParcelFileDescriptor.class, BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
    .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
    /* GIFs */
    .prepend(InputStream.class, GifDrawable.class,
        new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
    .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
    .register(GifDrawable.class, new GifDrawableEncoder())
    /* GIF Frames */
    .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory&lt;GifDecoder&gt;())
    .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
    /* Files */
    .register(new ByteBufferRewinder.Factory())
    .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
    .append(File.class, InputStream.class, new FileLoader.StreamFactory())
    .append(File.class, File.class, new FileDecoder())
    .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
    .append(File.class, File.class, new UnitModelLoader.Factory&lt;File&gt;())
    /* Models */
    .register(new InputStreamRewinder.Factory(arrayPool))
    .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
    .append(
            int.class,
            ParcelFileDescriptor.class,
            new ResourceLoader.FileDescriptorFactory(resources))
    .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
    .append(
            Integer.class,
            ParcelFileDescriptor.class,
            new ResourceLoader.FileDescriptorFactory(resources))
    .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
    .append(String.class, InputStream.class, new StringLoader.StreamFactory())
    .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
    .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
    .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
    .append(
            Uri.class,
            ParcelFileDescriptor.class,
            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
    .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
    .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
    .append(
        Uri.class,
         InputStream.class,
         new UriLoader.StreamFactory(context.getContentResolver()))
    .append(Uri.class, ParcelFileDescriptor.class,
         new UriLoader.FileDescriptorFactory(context.getContentResolver()))
    .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
    .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
    .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
    .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
    .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
    .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
    /* Transcoders */
    .register(Bitmap.class, BitmapDrawable.class,
        new BitmapDrawableTranscoder(resources, bitmapPool))
    .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
    .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());

ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
glideContext =
    new GlideContext(
        context, registry, imageViewTargetFactory, defaultRequestOptions,
        defaultTransitionOptions, engine, logLevel);
</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码可以看出，完成对registry对象的各种注册(太多了有木有眼花)，带着问题我们只分析和网络图片加载相关的。</div></pre></td></tr></table></figure></p>
<p>.append(String.class, InputStream.class, new StringLoader.StreamFactory()<br>.append(Uri.class, InputStream.class, new HttpUriLoader.Factory())<br>.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以上代码可以看出，分别对String.class、Uri.class、GlideUrl.class三种类型注入了不同的Factory，这个Factory使用创建ModelLoader的，ModelLoader就是用来加载图片的。说的不是很清楚，**这里只需要明白，registry分别对这三种类型注册了生成ModelLoader的工厂类**。</div><div class="line"></div><div class="line">接着，进入Registry类中，看看怎么缓存这些功能类的。</div></pre></td></tr></table></figure></p>
<p>public class Registry {<br>  //各种功能类注册器。加载、转换、解码、加密等。<br>  private final ModelLoaderRegistry modelLoaderRegistry;<br>  private final EncoderRegistry encoderRegistry;<br>  private final ResourceDecoderRegistry decoderRegistry;<br>  private final ResourceEncoderRegistry resourceEncoderRegistry;<br>  private final DataRewinderRegistry dataRewinderRegistry;<br>  private final TranscoderRegistry transcoderRegistry;<br>  private final ImageHeaderParserRegistry imageHeaderParserRegistry;</p>
<pre><code>...
 modelLoader注册
 public &lt;Model, Data&gt; Registry append(Class&lt;Model&gt; modelClass, Class&lt;Data&gt; dataClass,
      ModelLoaderFactory&lt;Model, Data&gt; factory) {
    modelLoaderRegistry.append(modelClass, dataClass, factory);
    return this;
  }

...
</code></pre><p>  }</p>
<p>  //继续跟进代码。ModelLoaderRegistry类中<br>  public synchronized <model, data=""> void append(Class<model> modelClass, Class<data> dataClass,<br>      ModelLoaderFactory<model, data=""> factory) {<br>    multiModelLoaderFactory.append(modelClass, dataClass, factory);<br>    cache.clear();<br>  }</model,></data></model></model,></p>
<p>  //最后进入MultiModelLoaderFactory类中的add方法<br>  private <model, data=""> void add(Class<model> modelClass, Class<data> dataClass,<br>      ModelLoaderFactory<model, data=""> factory, boolean append) {<br>    Entry<model, data=""> entry = new Entry&lt;&gt;(modelClass, dataClass, factory);<br>    //entries是一个list。所以，到这里就知道注册的LoaderFactory被缓存到了列表中，以便后面取用。<br>    entries.add(append ? entries.size() : 0, entry);<br>  }</model,></model,></data></model></model,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">通过以上代码分析，知道了ModelLoaderFactory在Glide实例化时被注册到了一个列表中,以待获取使用。在分析DecodeJob代码逻辑时，我们知道SourceGenerator是加载资源的，下面我们就**看下SourceGenerator是怎么获取上面注册的ModelLoader并完成数据加载的。**</div></pre></td></tr></table></figure>
<p>  //DecodeJob调用SourceGenerator的startNext方法执行任务。<br>  @Override<br>  public boolean startNext() {<br>    //忽略缓存部分逻辑<br>    if (dataToCache != null) {<br>      Object data = dataToCache;<br>      dataToCache = null;<br>      cacheData(data);<br>    }</p>
<pre><code>if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) {
  return true;
}
sourceCacheGenerator = null;

loadData = null;
boolean started = false;
while (!started &amp;&amp; hasNextModelLoader()) {
  //num=8
  loadData = helper.getLoadData().get(loadDataListIndex++);
  if (loadData != null
      &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
      || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
    started = true;
    //num=9 这里是真正调用fetcher.loadData方法加载数据的地方。
    loadData.fetcher.loadData(helper.getPriority(), this);
  }
}
return started;
</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以上代码 **num=9** 注释处，可以看出loadData对象是通过helper.getLoadData（）返回并在while中条件筛选得到。接着看下这个helper类是什么来头。</div><div class="line"></div><div class="line">首先DecodeHelper是在DecodeJob中实例化的。</div></pre></td></tr></table></figure>
<p>//DecodeJob类中，decodeHelper调用init方式的代码片段<br>decodeHelper.init(<br>        glideContext,<br>        model, //String类型，对应load(myUrl)中的myUrl.<br>        signature,<br>        width,<br>        height,<br>        diskCacheStrategy,<br>        resourceClass, //默认是Object.class<br>        transcodeClass, //默认是Drawable.class<br>        priority,<br>        options,<br>        transformations,<br>        isTransformationRequired,<br>        isScaleOnlyOrNoTransform,<br>        diskCacheProvider);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">知道model变量的类型，对获取ModelLoader逻辑理解很重要。现在我们去DecodeHelper类中查看getLoadData方法。（对应上一个代码块中 **num=8注释处** ）</div></pre></td></tr></table></figure></p>
<p>List<loaddata<?>&gt; getLoadData() {<br>    if (!isLoadDataSet) {<br>      isLoadDataSet = true;<br>      loadData.clear();<br>      //根据model类型，通过Glide对应Registry获取ModelLoader列表。<br>      List<modelloader<object, ?="">&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);<br>      int size = modelLoaders.size();<br>      for (int i = 0; i &lt; size; i++) {<br>        ModelLoader<object, ?=""> modelLoader = modelLoaders.get(i);<br>        LoadData&lt;?&gt; current =<br>            modelLoader.buildLoadData(model, width, height, options);<br>            //循环创建出LoadData，用户后面加载。<br>        if (current != null) {<br>          loadData.add(current);<br>        }<br>      }<br>    }<br>    return loadData;<br>  }<br>  //Registry类中getModelLoaders方法，没什么说的。<br>  //但要知道modelLoaderRegistry早在Glide实例化时已注册了所有ModelLoaderFactory就行。<br>  public <model> List<modelloader<model, ?="">&gt; getModelLoaders(Model model) {<br>    List<modelloader<model, ?="">&gt; result = modelLoaderRegistry.getModelLoaders(model);<br>    if (result.isEmpty()) {<br>      throw new NoModelLoaderAvailableException(model);<br>    }<br>    return result;<br>  }</modelloader<model,></modelloader<model,></model></object,></modelloader<object,></loaddata<?></p>
<p>  //进入ModelLoaderRegistry类<br>  public synchronized <a> List<modelloader<a, ?="">&gt; getModelLoaders(A model) {<br>    List<modelloader<a, ?="">&gt; modelLoaders = getModelLoadersForClass(getClass(model));<br>    int size = modelLoaders.size();<br>    List<modelloader<a, ?="">&gt; filteredLoaders = new ArrayList&lt;&gt;(size);<br>    for (int i = 0; i &lt; size; i++) {<br>      ModelLoader<a, ?=""> loader = modelLoaders.get(i);<br>      if (loader.handles(model)) {<br>        filteredLoaders.add(loader);<br>      }<br>    }<br>    return filteredLoaders;<br>  }</a,></modelloader<a,></modelloader<a,></modelloader<a,></a></p>
<p>  //将modelClass（默认是String.class）参数，通过multiModelLoaderFactory.build方法创建出ModelLoader。<br>  //可以看出，这里loader也是做了缓存的，避免重复build对象。<br>  private <a> List<modelloader<a, ?="">&gt; getModelLoadersForClass(Class<a> modelClass) {<br>    List<modelloader<a, ?="">&gt; loaders = cache.get(modelClass);<br>    if (loaders == null) {<br>      loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));<br>      cache.put(modelClass, loaders);<br>    }<br>    return loaders;<br>  }</modelloader<a,></a></modelloader<a,></a></p>
<p>  @SuppressWarnings(“unchecked”)<br>  private static <a> Class<a> getClass(A model) {<br>    return (Class<a>) model.getClass();<br>  }</a></a></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">到这里，我们再理一下思路。资源加载器SourceGenerator，使用特定model类型，通过Register获取已经注册过的ModelLoader列表，当然这个ModelLoader是通过注册的xxxFactory.build而来，拿到ModelLoader列表后，在通过modelLoader.buildLoadData方法转化为LoadData对象列表，最后就是在加载器SourceGenerator中调用以下代码执行加载数据。</div></pre></td></tr></table></figure>
<p>loadData.fetcher.loadData(helper.getPriority(), this);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">再来看之前注入的三个loaderFactory</div></pre></td></tr></table></figure></p>
<p>.append(String.class, InputStream.class, new StringLoader.StreamFactory()<br>.append(Uri.class, InputStream.class, new HttpUriLoader.Factory())<br>.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">告诉大家，通过Glide.with(this).load(myUrl).into(view)，真正加载网络图片对应的loader是HttpGlideUrlLoader。**先来看下为什么是它？明明传入的是String而非GlideUrl。**</div><div class="line"></div><div class="line">按照类型注册，那匹配会先获取到StringLoader.StreamFactory。</div></pre></td></tr></table></figure></p>
<p>public class StringLoader<data> implements ModelLoader<string, data=""> {<br>  private final ModelLoader<uri, data=""> uriLoader;</uri,></string,></data></p>
<p>  public StringLoader(ModelLoader<uri, data=""> uriLoader) {<br>    this.uriLoader = uriLoader;<br>  }</uri,></p>
<p>  @Override<br>  public LoadData<data> buildLoadData(String model, int width, int height,<br>      Options options) {<br>    Uri uri = parseUri(model);<br>    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);<br>  }</data></p>
<p>  /**</p>
<ul>
<li><p>Factory for loading {@link InputStream}s from Strings.<br>*/<br>public static class StreamFactory implements ModelLoaderFactory<string, inputstream=""> {</string,></p>
<p>@Override<br>public ModelLoader<string, inputstream=""> build(MultiModelLoaderFactory multiFactory) {<br> //num=10<br> return new StringLoader&lt;&gt;(multiFactory.build(Uri.class, InputStream.class));<br>}</string,></p>
<p>@Override<br>public void teardown() {<br> // Do nothing.<br>}<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在 **num=10** 注释处，MultiModelLoaderFactory通过Uri.class和InputStream.class创建一个ModelLoader给StringLoader，所以StringLoader的加载功能转移了。而且根据注册关系知道转移到了HttpUriLoader中。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>public class HttpUriLoader implements ModelLoader<uri, inputstream=""> {<br>  private static final Set<string> SCHEMES =<br>      Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(“http”, “https”)));</string></uri,></p>
<p>  private final ModelLoader<glideurl, inputstream=""> urlLoader;</glideurl,></p>
<p>  public HttpUriLoader(ModelLoader<glideurl, inputstream=""> urlLoader) {<br>    this.urlLoader = urlLoader;<br>  }</glideurl,></p>
<p>  @Override<br>  public LoadData<inputstream> buildLoadData(Uri model, int width, int height, Options options) {<br>    return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);<br>  }</inputstream></p>
<p>  @Override<br>  public boolean handles(Uri model) {<br>    return SCHEMES.contains(model.getScheme());<br>  }</p>
<p>  /**</p>
<ul>
<li><p>Factory for loading {@link InputStream}s from http/https {@link Uri}s.<br>*/<br>public static class Factory implements ModelLoaderFactory<uri, inputstream=""> {</uri,></p>
<p>@Override<br>public ModelLoader<uri, inputstream=""> build(MultiModelLoaderFactory multiFactory) {<br> //num=11 MD又转移了，这次转移到了HttpGlideUrlLoader<br> return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));<br>}</uri,></p>
<p>@Override<br>public void teardown() {<br> // Do nothing.<br>}<br>}<br>}</p>
</li>
</ul>
<p>//跟进HttpGlideUrlLoader类<br>public class HttpGlideUrlLoader implements ModelLoader<glideurl, inputstream=""> {<br>  /**</glideurl,></p>
<ul>
<li>An integer option that is used to determine the maximum connect and read timeout durations (in</li>
<li>milliseconds) for network connections.<br>*</li>
<li><p></p><p>Defaults to 2500ms.<br>*/<br>public static final Option<integer> TIMEOUT = Option.memory(<br> “com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout”, 2500);</integer></p>
<p>@Nullable private final ModelCache<glideurl, glideurl=""> modelCache;</glideurl,></p>
<p>public HttpGlideUrlLoader() {<br>this(null);<br>}</p>
<p>public HttpGlideUrlLoader(ModelCache<glideurl, glideurl=""> modelCache) {<br>this.modelCache = modelCache;<br>}</glideurl,></p>
<p>@Override<br>public LoadData<inputstream> buildLoadData(GlideUrl model, int width, int height,<br> Options options) {<br>// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time<br>// spent parsing urls.<br>GlideUrl url = model;<br>if (modelCache != null) {<br> url = modelCache.get(model, 0, 0);<br> if (url == null) {<br>   modelCache.put(model, 0, 0, model);<br>   url = model;<br> }<br>}<br>int timeout = options.get(TIMEOUT);<br>//创建LoadData，新建的HttpUrlFetcher<br>return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));<br>}</inputstream></p>
<p>@Override<br>public boolean handles(GlideUrl model) {<br>return true;<br>}</p>
<p>/**</p>
</li>
<li><p>The default factory for {@link HttpGlideUrlLoader}s.<br>*/<br>public static class Factory implements ModelLoaderFactory<glideurl, inputstream=""> {<br>private final ModelCache<glideurl, glideurl=""> modelCache = new ModelCache&lt;&gt;(500);</glideurl,></glideurl,></p>
<p>@Override<br>public ModelLoader<glideurl, inputstream=""> build(MultiModelLoaderFactory multiFactory) {<br> //可以看出HttpGlideUrlLoader打算自己处理<br> return new HttpGlideUrlLoader(modelCache);<br>}</glideurl,></p>
<p>@Override<br>public void teardown() {<br> // Do nothing.<br>}<br>}<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">到这里就知道了，**load(myUrl)** 实际加载是使用的**HttpGlideUrlLoader**，对应的Fetcher就是**HttpUrlFetcher**。</div><div class="line"></div><div class="line">最后贴下HttpUrlFetcher代码</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.<br>*/<br>public class HttpUrlFetcher implements DataFetcher<inputstream> {</inputstream></p>
<p>public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {<br> this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);<br>}</p>
<p>// Visible for testing.<br>HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {<br> this.glideUrl = glideUrl;<br> this.timeout = timeout;<br> this.connectionFactory = connectionFactory;<br>}</p>
<p>@Override<br>public void loadData(Priority priority, DataCallback&lt;? super InputStream&gt; callback) {<br> long startTime = LogTime.getLogTime();<br> final InputStream result;<br> try {<br>   result = loadDataWithRedirects(glideUrl.toURL(), 0 /<em>redirects</em>/, null /<em>lastUrl</em>/,</p>
<pre><code>glideUrl.getHeaders());
</code></pre><p> } catch (IOException e) {<br>   if (Log.isLoggable(TAG, Log.DEBUG)) {</p>
<pre><code>Log.d(TAG, &quot;Failed to load data for url&quot;, e);
</code></pre><p>   }<br>   callback.onLoadFailed(e);<br>   return;<br> }</p>
<p> if (Log.isLoggable(TAG, Log.VERBOSE)) {<br>   Log.v(TAG, “Finished http url fetcher fetch in “ + LogTime.getElapsedMillis(startTime)</p>
<pre><code>+ &quot; ms and loaded &quot; + result);
</code></pre><p> }<br> callback.onDataReady(result);<br>}</p>
<p>private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,<br>   Map<string, string=""> headers) throws IOException {<br> if (redirects &gt;= MAXIMUM_REDIRECTS) {<br>   throw new HttpException(“Too many (&gt; “ + MAXIMUM_REDIRECTS + “) redirects!”);<br> } else {<br>   // Comparing the URLs using .equals performs additional network I/O and is generally broken.<br>   // See <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html" target="_blank" rel="external">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>.<br>   try {</string,></p>
<pre><code>if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) {
  throw new HttpException(&quot;In re-direct loop&quot;);

}
</code></pre><p>   } catch (URISyntaxException e) {</p>
<pre><code>// Do nothing, this is best effort.
</code></pre><p>   }<br> }</p>
<p> urlConnection = connectionFactory.build(url);<br> for (Map.Entry<string, string=""> headerEntry : headers.entrySet()) {<br>   urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());<br> }<br> urlConnection.setConnectTimeout(timeout);<br> urlConnection.setReadTimeout(timeout);<br> urlConnection.setUseCaches(false);<br> urlConnection.setDoInput(true);</string,></p>
<p> // Stop the urlConnection instance of HttpUrlConnection from following redirects so that<br> // redirects will be handled by recursive calls to this method, loadDataWithRedirects.<br> urlConnection.setInstanceFollowRedirects(false);</p>
<p> // Connect explicitly to avoid errors in decoders if connection fails.<br> urlConnection.connect();<br> if (isCancelled) {<br>   return null;<br> }<br> final int statusCode = urlConnection.getResponseCode();<br> if (statusCode / 100 == 2) {<br>   return getStreamForSuccessfulRequest(urlConnection);<br> } else if (statusCode / 100 == 3) {<br>   String redirectUrlString = urlConnection.getHeaderField(“Location”);<br>   if (TextUtils.isEmpty(redirectUrlString)) {</p>
<pre><code>throw new HttpException(&quot;Received empty or null redirect url&quot;);
</code></pre><p>   }<br>   URL redirectUrl = new URL(url, redirectUrlString);<br>   return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);<br> } else if (statusCode == -1) {<br>   throw new HttpException(statusCode);<br> } else {<br>   throw new HttpException(urlConnection.getResponseMessage(), statusCode);<br> }<br>}</p>
<p>private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)<br>   throws IOException {<br> if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {<br>   int contentLength = urlConnection.getContentLength();<br>   stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);<br> } else {<br>   if (Log.isLoggable(TAG, Log.DEBUG)) {</p>
<pre><code>Log.d(TAG, &quot;Got non empty content encoding: &quot; + urlConnection.getContentEncoding());
</code></pre><p>   }<br>   stream = urlConnection.getInputStream();<br> }<br> return stream;<br>}</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">终于看到了网络通讯代码。比较简单，就是通过HttpURLConnection获取数据流并返回。当然你也可以使用Okhttp来加载，具体用法请查询官网。</div><div class="line"></div><div class="line">到这里，已经分析完Glide的整个加载过程，剩下就简单说下回调刷新UI部分。</div><div class="line"></div><div class="line">#### 回调刷新UI</div><div class="line"></div><div class="line">回到DecodeJob类中</div></pre></td></tr></table></figure></p>
<p>@Override<br>  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,<br>      DataSource dataSource, Key attemptedKey) {<br>      …<br>      //资源加载完成后回调，执行<br>      decodeFromRetrievedData();<br>      …<br>  }<br>  /处理源数据<br>  private void decodeFromRetrievedData() {<br>    if (Log.isLoggable(TAG, Log.VERBOSE)) {<br>      logWithTimeAndKey(“Retrieved data”, startFetchTime,<br>          “data: “ + currentData</p>
<pre><code>      + &quot;, cache key: &quot; + currentSourceKey
      + &quot;, fetcher: &quot; + currentFetcher);
}
Resource&lt;R&gt; resource = null;
try {
  //比如缩放，转换等。会判断currentDataSource类型。
  resource = decodeFromData(currentFetcher, currentData, currentDataSource);
} catch (GlideException e) {
  e.setLoggingDetails(currentAttemptingKey, currentDataSource);
  exceptions.add(e);
}
if (resource != null) {
  notifyEncodeAndRelease(resource, currentDataSource);
} else {
  runGenerators();
}
</code></pre><p>  }</p>
<p>  private void notifyEncodeAndRelease(Resource<r> resource, DataSource dataSource) {<br>    if (resource instanceof Initializable) {<br>      ((Initializable) resource).initialize();<br>    }</r></p>
<pre><code>Resource&lt;R&gt; result = resource;
LockedResource&lt;R&gt; lockedResource = null;
if (deferredEncodeManager.hasResourceToEncode()) {
  lockedResource = LockedResource.obtain(resource);
  result = lockedResource;
}
//通过完成，并回调。
notifyComplete(result, dataSource);

stage = Stage.ENCODE;
try {
  //磁盘缓存
  if (deferredEncodeManager.hasResourceToEncode()) {
    deferredEncodeManager.encode(diskCacheProvider, options);
  }
} finally {
  if (lockedResource != null) {
    lockedResource.unlock();
  }
  onEncodeComplete();
}
</code></pre><p>  }</p>
<p>  private void notifyComplete(Resource<r> resource, DataSource dataSource) {<br>    setNotifiedOrThrow();<br>    //这里的callback就是EngineJob<br>    callback.onResourceReady(resource, dataSource);<br>  }</r></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码看出,DecodeJob加载完数据后，会做转换、缓存等操作，这些咱不细究，关注回调流程即可。</div></pre></td></tr></table></figure>
<p>//来到EngineJob类中<br>@Override<br>  public void onResourceReady(Resource<r> resource, DataSource dataSource) {<br>    this.resource = resource;<br>    this.dataSource = dataSource;<br>    //将回调过程通过Handler切换到主线程<br>    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();<br>  }</r></p>
<p>   @Override<br>    public boolean handleMessage(Message message) {<br>      EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj;<br>      switch (message.what) {<br>        case MSG_COMPLETE:<br>          job.handleResultOnMainThread();<br>          break;<br>        case MSG_EXCEPTION:<br>          job.handleExceptionOnMainThread();<br>          break;<br>        case MSG_CANCELLED:<br>          job.handleCancelledOnMainThread();<br>          break;<br>        default:<br>          throw new IllegalStateException(“Unrecognized message: “ + message.what);<br>      }<br>      return true;<br>    }</p>
<p>  @Synthetic<br>  void handleResultOnMainThread() {<br>    stateVerifier.throwIfRecycled();<br>    if (isCancelled) {<br>      resource.recycle();<br>      release(false /<em>isRemovedFromQueue</em>/);<br>      return;<br>    } else if (cbs.isEmpty()) {<br>      throw new IllegalStateException(“Received a resource without any callbacks to notify”);<br>    } else if (hasResource) {<br>      throw new IllegalStateException(“Already have resource”);<br>    }<br>    engineResource = engineResourceFactory.build(resource, isCacheable);<br>    hasResource = true;</p>
<pre><code>// Hold on to resource for duration of request so we don&apos;t recycle it in the middle of
// notifying if it synchronously released by one of the callbacks.
engineResource.acquire();
//通知并缓存到activeResources（内存缓存中的一种）中。
listener.onEngineJobComplete(key, engineResource);

for (ResourceCallback cb : cbs) {
  if (!isInIgnoredCallbacks(cb)) {
    engineResource.acquire();
    //这里将回调到SingleRequest的onResourceReady中。
    cb.onResourceReady(engineResource, dataSource);
  }
}
// Our request is complete, so we can release the resource.
engineResource.release();

release(false /*isRemovedFromQueue*/);
</code></pre><p>  }</p>
<p>  //继续跟进SingleRequest类<br>  @Override<br>  public void onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) {<br>    …<br>    onResourceReady((Resource<r>) resource, (R) received, dataSource);<br>  }</r></p>
<p>  private void onResourceReady(Resource<r> resource, R result, DataSource dataSource) {<br>    // We must call isFirstReadyResource before setting status.<br>    boolean isFirstResource = isFirstReadyResource();<br>    status = Status.COMPLETE;<br>    this.resource = resource;</r></p>
<pre><code>if (requestListener == null
    || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
  Transition&lt;? super R&gt; animation =
      animationFactory.build(dataSource, isFirstResource);
//如果没有设置requestListener或者未消耗事件，就会回调target的onResourceReady方法。
//默认的target是DrawableImageViewTarget     
  target.onResourceReady(result, animation);
}

notifyLoadSuccess();
</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从以上代码得知，回调从Decodejob出来，在EngineJob中切换到主线程并一路回调到DrawableImageViewTarget中，至于为什么默认是DrawableImageViewTarget，请查看RequestBuilder中into方法。下面我们再看下DrawableImageViewTarget相关代码，也是设置显示图片的地方。</div></pre></td></tr></table></figure>
<p>public class DrawableImageViewTarget extends ImageViewTarget<drawable> {</drawable></p>
<p>  public DrawableImageViewTarget(ImageView view) {<br>    super(view);<br>  }</p>
<p>  @Override<br>  protected void setResource(@Nullable Drawable resource) {<br>    //实现了该方法。简单将drawable设置给imageview。<br>    view.setImageDrawable(resource);<br>  }<br>}</p>
<p>public abstract class ImageViewTarget<z> extends ViewTarget<imageview, z=""><br>    implements Transition.ViewAdapter {</imageview,></z></p>
<p>  public ImageViewTarget(ImageView view) {<br>    super(view);<br>  }</p>
<p>  @Override<br>  public void onResourceReady(Z resource, @Nullable Transition&lt;? super Z&gt; transition) {<br>    if (transition == null || !transition.transition(resource, this)) {<br>      setResourceInternal(resource);<br>    } else {<br>      maybeUpdateAnimatable(resource);<br>    }<br>  }</p>
<p>  private void setResourceInternal(@Nullable Z resource) {<br>    maybeUpdateAnimatable(resource);<br>    setResource(resource);<br>  }</p>
<p>  private void maybeUpdateAnimatable(@Nullable Z resource) {<br>    if (resource instanceof Animatable) {<br>      animatable = (Animatable) resource;<br>      animatable.start();<br>    } else {<br>      animatable = null;<br>    }<br>  }</p>
<p>  protected abstract void setResource(@Nullable Z resource);<br>}</p>
<p>```<br>可以看到，onResourceReady在父类ImageViewTarget中回调，然后调用setResource将图片设置并显示出来。代码执行到这里，回调过程也就完了。Glide的整个执行流程也分析完了。</p>
<h3 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h3><ul>
<li><p>文章太长</p>
<p>虽然一直在强调只分析主流程，不关心细节，但还是写了怎么多，囧~。后面的注意了，毕竟长篇幅，问题难免考虑周全，也不易于阅读。</p>
</li>
<li><p>RTFSC (Read the fucking source code )</p>
<p>遇到问题，第一时间想到的应该是阅读源码。</p>
</li>
<li><p>将知识点与自己连接起来</p>
<p>我以前一直有个问题，看到喜欢的文章就会收藏，想的是后面慢慢看，或者用到的时候能找到就行；但久了发现收藏的文章基本和自己没啥关系，什么用到的时候能找到？别想，基本能全忘记，啥印象都没。但现在<strong>看到好文章，我至少得评论下，甚至花时间梳理，这样对知识点就有了连接，才有可能日后为你所用。</strong></p>
</li>
</ul>
<p>限于水平有限，文中定有错误和疏漏之处，恳请赐教。若有不明白之处，欢迎随时评论交流。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android-glide-源码/" rel="tag"># android glide 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/28/java-design-patterns-creator/" rel="next" title="设计模式之创建型模式">
                <i class="fa fa-chevron-left"></i> 设计模式之创建型模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar_x225.jpeg"
              alt="Jiantao" />
          
            <p class="site-author-name" itemprop="name">Jiantao</p>
            <p class="site-description motion-element" itemprop="description">believe , passion , persistent.</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本用法"><span class="nav-number">1.</span> <span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结下"><span class="nav-number">1.1.</span> <span class="nav-text">总结下</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiantao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("TtBkE4yS0DgwwJ7ew5J8lC2i-gzGzoHsz", "OYl57QlnOB4NOSU5UWfyvV6h");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  


</body>
</html>
